= Notes on 'Fulcro 3 YT Tutorial'
:toc:
:toclevels: 2

:root-dir: .

:yt-fulcro-1-id: wEjNWUMCX78
:yt-fulcro-2-id: HCVzG2BLRwk
:yt-fulcro-3-id: KJsFLmkdRig
:yt-fulcro-4-id: vNKYl-5x8Ao
:yt-fulcro-5-id: JBy_htHxygo
:yt-fulcro-6-id: F7QzFpo8pA0

:yt-fulcro-1: https://www.youtube.com/watch?v={yt-fulcro-1-id}
:yt-fulcro-2: https://www.youtube.com/watch?v={yt-fulcro-2-id}
:yt-fulcro-3: https://www.youtube.com/watch?v={yt-fulcro-3-id}
:yt-fulcro-4: https://www.youtube.com/watch?v={yt-fulcro-4-id}
:yt-fulcro-5: https://www.youtube.com/watch?v={yt-fulcro-5-id}
:yt-fulcro-6: https://www.youtube.com/watch?v={yt-fulcro-6-id}

:yt-fulcro-1t: https://youtu.be/{yt-fulcro-1-id}?t=
:yt-fulcro-2t: https://youtu.be/{yt-fulcro-2-id}?t=
:yt-fulcro-3t: https://youtu.be/{yt-fulcro-3-id}?t=
:yt-fulcro-4t: https://youtu.be/{yt-fulcro-4-id}?t=
:yt-fulcro-5t: https://youtu.be/{yt-fulcro-5-id}?t=
:yt-fulcro-6t: https://youtu.be/{yt-fulcro-6-id}?t=

//''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

== Usage ==

=== Client ===

1/ To start shadow process:

[source, bash]
----
bb client:run
----

2/ Connect to Shadow nREPL (if you use Cursive, you can use attached 'client REPL' run config)

3/ To switch to ClojureScript REPL call:

[source, clojure]
----
(dev)
----

When the steps are completed two URLs should be available:

* http://localhost:9630 - ShadowCLJ page
* http://localhost:8000 - website

=== Server ===

1/ Run nREPL process

[source, bash]
----
bb server:repl
----

2/ Connect to server nREPL (if you use Cursive, you can use attached 'server REPL (remote)' run config)

3/ Setup repl on start

[source, clojure]
----
(dev)
----

4/ Start server

[source, clojure]
----
(start)
----

When the steps are completed the below URL should be available:

* http://localhost:3000 - website & api

//''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

== Docs ==

* Fulcro book v3: https://book.fulcrologic.com/
* Pathom docs v3: https://blog.wsscode.com/pathom/
* Pathom docs v2: https://blog.wsscode.com/pathom/v2/pathom/2.2.0/introduction.html[https://blog.wsscode.com/pathom/v2]

//''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

== Videos ==

=== link:{yt-fulcro-1}[Fulcro – Part 1: Getting Started] ===

video::{yt-fulcro-1-id}[youtube, start=, end=, width=1280, height=720]

==== Content ====

* initial files
* intro to IntelliJ Idea
* how to use Cursive & use REPL from it

==== Notes ====

Commit: "part-1: Add bare project". It includes:

* bare minimal project, incl.
 ** deps.edn, shadow-cljs.edn, index.html
 ** simple client code (cljs) showing "Hello World"

* amended compare to the video
 ** replaced `def APP` with `defonce APP` (possible bug, {yt-fulcro-1t}4m13s[client in part 1], {yt-fulcro-2t}0m0s[client part 2])
 ** added bb.edn
 ** upgraded to the latest versions
  *** fulcro: 3.5.34
  *** shadow-cljs: 2.20.20
  *** react & react-dom: 17.0.2
  *** clojure 1.11.1, clojurescript 1.11.60
  *** jvm: 11.0.17 (Corretto-11.0.17.8.1)
  *** nvm: v18.13.0
 ** fixed 1.11.1 warnings by using newer `com.taoensso/sente`
 ** added `app.client/refresh` to use it for hot reloads

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

=== link:{yt-fulcro-2}[Fulcro – Part 2: Normalization] ===

video::{yt-fulcro-2-id}[youtube, start=, end=, width=1280, height=720]

==== Content ====

* simple layout to list person, their age and they cars
* more on components (idents, query)
* `merge-component!`
* normalized database

==== Notes ====

* `merge-component!` works by taking an ident from the given data and injecting that into APP
* you can't merge root component with `merge-component!` ({yt-fulcro-2t}16m57s[16:57])
* `merge-component!` support replacing particular top thing by added edge (`:replace`)
* `merge-component!` with `:append` adds an edge to given position

==== Commits ====

* *part-2: Demo normalization on simple layout*
** Simple layout includes showing person details:
*** name
*** age
*** cars
** Comments showing how to merge data to the database

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

=== link:{yt-fulcro-3}[Fulcro – Part 3: Initial State and Mutations] ===

video::KJsFLmkdRig[youtube, start=0, end=, width=1280, height=720]

==== Notes ====

===== Initial state _({yt-fulcro-3t}00m00s[00:00])_ =====

The initial state is provided on initial mount (on `(app/mount)`).
Mount is looking at things that need to be there for the first frame to render reasonably.

It is for purely client site setup like:

* UI routing,
* empty state values.

There are two notations for providing initial state.

Longer version:

[source,clojure]
----
:initial-state (fn [{:keys [id name]}]
                   {:person/id   id
                    :person/name name
                    :person/age  20
                    :person/cars [(comp/get-initial-state Car {:id 40 :model "Leaf"})
                                  (comp/get-initial-state Car {:id 41 :model "Escort"})
                                  (comp/get-initial-state Car {:id 42 :model "Sienna"})]})
----

And shorter:

[source,clojure]
----
:initial-state {:person/id   :param/id
                :person/name :param/name
                :person/age  20
                :person/cars [{:id 40 :model "Leaf"}
                              {:id 41 :model "Escort"}
                              {:id 42 :model "Sienna"}]}
----

The shorter version is shorter and gets more error checking
(if you misspell keyword it will point it out).

[CAUTION]
====
The type of data used in examples usually reside on the backend.
In the initial state we provide only purely clients data.
====

===== Mutations _({yt-fulcro-3t}11m18s[11:18])_ =====

* mutation looks like a function, but it returns only data
* `defmutation` in addition, registers mutation name to access later the effects (`action`, `remote`, etc)
* `comp/transact!` is used to apply mutation
* mutation can be visible or not visible at the code level where it is used
* to use it when it is not visible, quote it (optionally unquote params), although IDE will still highlight it
* lots of people hold mutations in separate file from the UI (separation between implementation & the view)

==== Commits ====

* *part-3: Add initial state*
** adds initial state for the app, so when reloaded is not empty

* *part-3: Demo mutations with 'make older' btn*
** adds one button 'make older' that applies mutation to the current user

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

=== link:{yt-fulcro-4}[Fulcro – Part 4 : Components, DOM, and React] ===

video::{yt-fulcro-4-id}[youtube, start=0, end=, width=1280, height=720]

==== Notes ====

===== Styling _({yt-fulcro-4t}00m00s[0:00])_ =====

* to apply styles you can use either:
** short version: `(div :.ui.form ...)`
** long version: `(div {:className "ui form"} ...)`
* `div` is at the same time both function and macro.
Depends on situation fulcro decides to use one or another.
* because macros are evaluated in compile time, and
because of it, fulcro is able to get you exact same
code that JSX would generate for you
* for best performence it is worth to drop the options mape, even if empty, eg. `(div {} ...)` instead of `(div ...)`

===== React lifecycle methods _({yt-fulcro-4t}06:41[06:41])_ =====

* component's map is open, extensible map
* both `:query` and `:initial-state` can be lambdas
* in case of dynamic query support, the `:query` has to be lambda (when data requested at runtime might be different than these setup statically)
* to request component options call `(comp/component-options)`
* react lifecycle methods are a little special in a way that they have a meaning to react, but `defsc` doesn't do anything to it
* `:shouldComponentUpdate` - whether should the component reload or not
* `:componentDidMount`
* `:initLocalState` - this one is a constructor placeholder for react instance.
Whatever is added here, goes to React local state. Local state can be accessed via comp/get-state
it is useful for performance as it.
* If you need to do anything at the construction time, this is the place.
* Tony uses local state very commonly for callback functions
* documentation of `defsc` tells more about these react methods
* fulcro is really fast in pulling data from internal db so typically overhead is not that big to justify trying to optimize by keeping the state in component local state

===== idents _({yt-fulcro-4t}16m26s[16:26])_ =====

* _"it's not uncommon for ust o have components that don't have server identity but for which we do want an identity in our local app database"_
** component that have ident but don't have server identity
** `PersonList` is such an example
* there are a couple of options to specify ident in the component options map:
** `:ident :person/id`
** `:ident [:PEOPLE :person/id]` - will use `:person/id` for ident but in the db it will use `:PEOPLE` as top name
** `:ident (fn [_ _] [:person/id (:person/id props)])` (equivalent of the first one)
* _"when we get to a singleton component, where there's only going to one representation in the database, the id part of the ident is constant, and so we don't want it computed at all"_
** in such scenario we could use `:ident (fn [_ _] [:component/id ::person-list])`

===== use react component _({yt-fulcro-4t}23m38s[23:38])_ =====

* shadow-cljs doesn't need to be restarted to see added libraries (with `npm install`)
* shadow-cljs provides a way to import JS
+
|===
|JavaScript | ClojureScript
| ES5 `const NumberFormat = require('react-number-format');`|`["react-number-format" :as NumberFormat]`
| ES6 `import NumberFormat from 'react-number-format';`|`["react-number-format" :as NumberFormat]`
| ES6 `import { NumericFormat } from 'react-number-format';`|`["react-number-format" :refer (NumericFormat)]`
|===
+
[INFO]
====
DOM inputs in HTML always take string inputs, and always return string outputs.
This includes time, date. Always strings. Remember!
====

==== Commits ====

* *part-4: Demo styling (use Semantic UI)*

* *part-4: Add sample react lifecycle methods*

* *part-4: Assign singleton ident (e.g. people list)*

* *part-4: use react lib (add numeric field)*

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

=== link:{yt-fulcro-5}[Fulcro – Part 5 : How Rendering Works] ===

video::{yt-fulcro-5-id}[youtube, start=0, end=, width=1280, height=720]

==== Notes ====

===== Optimisations _({yt-fulcro-5t}00m00s[0:00])_ =====

* fulcro laverages all react provides
* there is overhead with running the query
* stages
** 1. query
** 2. output of factories (VDOM)
** 3. react DOM diff
* fulcro optimizes:
** 1. query - reduce number of queries
** 2. output of factories (VDOM) - reduce the number that need to run period
** 3. react DOM diff (stable keys for react)
* setting `:shouldComponentUpdate` to true brings default react behaviour
`:shouldComponentUpdate (fn [this props state] true)`
* by default react computes all VDOM components and at the later stage decides via diffing what actually should go to the DOM

===== REPL fulcro components =====

* the optimisation are based on info like:
** what the component needs (`:query`)
** where in the database its data can be found (`:ident`)

* when the component like `Person` mounts, it can be indexed (7:20)
* to look at these indexes:
+
[source,clojure]
----
;; show all classes that query a prop :person/age
(comp/prop->classes APP :person/age) ; => #{:app.client/Person}

;; get class for given class key
(comp/registry-key->class :app.client/Person) ; => app.client/Person

;; show all components rendering Person
(comp/class->all APP Person) ; => #{#object[Component [object Object]] #object[Component [object Object]]}
(comp/class->all APP (comp/registry-key->class :app.client/Person)) ;; same as above

;; having component we can check its ident
(comp/get-ident component) ; => [:person/id 1]

;; get denormalized data having component's id
(let [state (app/current-state APP)
      component-query (comp/get-query Person)
      component-ident [:person/id 1]
      starting-entity (get-in state component-ident)]
   (fdn/db->tree component-query starting-entity state))
; => #:person{:id 1,
;             :name "Bob",
;             :age 20,
;             :cars [#:car{:id 40, :model "Leaf"} #:car{:id 41, :model "Escort"} #:car{:id 42, :model "Sienna"}]}
----
+
* `prop->classes` index trackes components by keyword not by class, because classes can change on hot code reload
* _"if I know `:person/age` changed, I can derive an upper bound for the things that need to be refreshed I need refresh all of the things that have class `Person` in this particular namespace."_
* and with `class->all` it is passible to find all the instances (components)
* with `fdn/db->tree` we can get denormalized data

* the ident based optimisation gets two states, the one before and the one after, and compares for every component whether the data it needs has changed or not

===== ident-optimized-render pros/cons =====

* ident-optimised-render relays on its dependants, but it doesn't check its internal data.
** in the example of ;counting people over 30' Tony shows that if we compute some data within a component based on data from components inside
*** the ident-optimised-render will not detect the change and will not re-render the `PersonList`
*** ident-optimised-render will re-render only the `Person` components that changed, it will not re-render `PersonList`
* so the easy choice is to use keyframe-render (actually in the latest version of the Fulcro this one is the default one)

* the other choice is to provide in a mutation a hint what should be refreshed via `:refresh` (commit `part-5: ident-optimized-render with :refresh`)

==== Commits ====

* *part-5: Log on rendering (but works incorrectly)*

* *part-5: Demo of funs to discover components)*

* *part-5: Demo ident-optimized-render pros/cons*

* *part-5: ident-optimized-render with :refresh*

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

=== link:{yt-fulcro-6}[Fulcro – Part 6 : Full Stack Part One] ===

video::{yt-fulcro-6-id}[youtube, start=0, end=, width=1280, height=720]

==== Content ====

* {yt-fulcro-6t}00m09s[00:09] - setup deps.edn
* {yt-fulcro-6t}02m25s[02:25] - setup pub resources (index.html)
* {yt-fulcro-6t}02m58s[02:58] - ring middleware & phatom parser
* {yt-fulcro-6t}05m00s[05:00] - some info on transit
* {yt-fulcro-6t}05m31s[05:31] - Cursive Run config for server
* {yt-fulcro-6t}06m13s[06:13] - discussing server's start/stop/restart
* {yt-fulcro-6t}06m20s[06:20] - Tony's keymap and Cursive REPL command restarting server
* {yt-fulcro-6t}08m41s[08:41] - discussing server's start/stop/restart - restarting/releasing resources
 ** these days Tony tends to use mount ({yt-fulcro-6t}09m30s[09:30])
* {yt-fulcro-6t}10m10s[10:10] - discussing server's start/stop/restart - discussing ns refresh (tools.namespace)
* {yt-fulcro-6t}12m40s[12:40] - connecting client
* {yt-fulcro-6t}14m20s[14:20] - more notes on transit
 ** transit knows how to encode data, how to encode bigdecimals
 ** _"if you use monetary units, let the big decimal come across"_
 ** how to handle bigdecimals in JavaScript and ClojureScript, how to make BigDecimals truly isomorphic
 ** _"don't make your types different among these two sides"_
* {yt-fulcro-6t}15m59s[15:59] - use tick for dates/times
* {yt-fulcro-6t}16m40s[16:40] - back to code, some changes to the code
* {yt-fulcro-6t}16m40s[18:18] - discussing model
 ** you can keep model in one space
 ** large namespace compiles long (that's why fulcro is split)
 ** two options we have:
  *** one cljc for all (spec, cljs, clj)
  *** one cljc for spec, one cljs and ona clj
  *** the best practice would be the second one ({yt-fulcro-6t}22m54s[22:54])
* {yt-fulcro-6t}22m56s[22:56] - refactor the model to follow best practice
* {yt-fulcro-6t}22m56s[22:56] - refactor the model (`Person`, `Car`) to follow best practice
* {yt-fulcro-6t}29m08s[29:08] - discussing code with Phatom resolvers
* {yt-fulcro-6t}31m05s[31:05] - showing Fulcro Inspect's Query tab
 ** {yt-fulcro-6t}41m05s[41:05] - `:all-people` is example of _global resolver_ (equivelent of _root resolver_ in GraphQL)
  *** _global resolvers_ can nest themselves because they require no context ({yt-fulcro-6t}41m20s[41:20])
  *** because of Pathom is schema-less, it is fine to put global resolvers anyware - it is one advantages of GraphQL
+
[source,clojure]
----
[{:all-people [:app.specs.person/name
               :app.specs.person/age
               {:all-people [:app.specs.person/id]}]}]
; => {:all-people [{:app.specs.person/name "Bob",
;                   :app.specs.person/age 22,}]}]
;                   :all-people [#:app.specs.person{:id 1} #:app.specs.person{:id 2}]}]}]
;                  {:app.specs.person/name "Sally",}}]}]
;                   :app.specs.person/age 26,}]}]
;                   :all-people [#:app.specs.person{:id 1} #:app.specs.person{:id 2}]}]}]
----
+
*** on of nice examples of it is using `:server/time` global resolver ({yt-fulcro-6t}43m32s[43:32])
+
[source,clojure]
----
[{:all-people [:app.specs.person/name
               :server/time]}]
; => {:all-people
;     [{:server/time #inst "2023-01-19T21:33:54.233-00:00",
;       :app.specs.person/name "Bob"}
;      {:server/time #inst "2023-01-19T21:33:54.233-00:00",
;       :app.specs.person/name "Sally"}]}
----
+
*** _"global resolvers are particularly handy since fulcro gives you normalization being able
     to grab things at any place in your query tree, it's quite handy because it doesn't matter
     if they are nested in the query because you are normalizing them at the end of the day"_

* {yt-fulcro-6t}44m02s[44:02] - populating the client with data from backend
** {yt-fulcro-6t}44m17s[44:17] usage of `:client-did-mount`
** {yt-fulcro-6t}44m34s[44:34] explanation of `df/load`
** {yt-fulcro-6t}44m34s[44:34] explanation of `df/load` & its `:target`

* {yt-fulcro-6t}48m10s[48:10] - mutation

** to make mutation fullstack you need to create a section in the client's mutation called `remote` and return there `true` ({yt-fulcro-6t}51m14s[51:14])
*** the word 'remote' actually is the default convention but you can change it to whatever you want if you also change the `:remote` keyword in the `:remotes` map ({yt-fulcro-6t}51m17s[51:17])

** {yt-fulcro-6t}50m05s[50:05] - be very careful what is returned from remote mutation
*** e.g. returning `(java.util.BitSet.)` breaks mutation ({yt-fulcro-6t}?t=53m24s[53:24])
*** keyword, empty map, whatever can be transcoded by transit is fine
*** you can also return something like an id `{::person/id id}` so Pathom could do more magic (some advanced tricks) ({yt-fulcro-6t}54m20s[54:20])


==== Notes ====

* In {yt-fulcro-6}[Part 6], Tony uses `p/error-handler-plugin` and he still gets an exception thrown locally.
  It no longer works that way in the latests stable Phatom 2 (v2.4.0). In the tutorial Tony used v2.2.24.
  To make the exception visible, I added a function printing the stacktrace. Alternatively, the plugin could be removed.


==== Commits ====

* *part-6: Make the app fullstack*
** uses newer version of fulcro 2.4.0
** to make exceptions visible I added `p/env-plugin` with function under `::p/process-error` key

//''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

== Writing this doc ==

I've been processing the all AsciiDoc files with command:
[source, bash]
----
asciidoctor **/*.adoc; fswatch -o **/*.adoc | xargs -n1 -I{} asciidoctor **/*.adoc
----

Plus serving the HTML via IntelliJ IDEA's `docs/README.html` > Open In > Browser > Firefox.

The link should be something like: http://localhost:63342/fulcro3-yt-tutorial/docs/README.html?&_ij_reload=RELOAD_ON_SAVE
