= Notes on 'Fulcro 3 YT Tutorial'
:toc:
:toclevels: 2

:root-dir: .

:yt-fulcro-1-id: wEjNWUMCX78
:yt-fulcro-2-id: HCVzG2BLRwk
:yt-fulcro-3-id: KJsFLmkdRig
:yt-fulcro-4-id: vNKYl-5x8Ao
:yt-fulcro-5-id: JBy_htHxygo

:yt-fulcro-1: https://www.youtube.com/watch?v={yt-fulcro-1-id}
:yt-fulcro-2: https://www.youtube.com/watch?v={yt-fulcro-2-id}
:yt-fulcro-3: https://www.youtube.com/watch?v={yt-fulcro-3-id}
:yt-fulcro-4: https://www.youtube.com/watch?v={yt-fulcro-4-id}
:yt-fulcro-5: https://www.youtube.com/watch?v={yt-fulcro-5-id}

:yt-fulcro-1t: https://youtu.be/{yt-fulcro-1-id}?t=
:yt-fulcro-2t: https://youtu.be/{yt-fulcro-2-id}?t=
:yt-fulcro-3t: https://youtu.be/{yt-fulcro-3-id}?t=
:yt-fulcro-4t: https://youtu.be/{yt-fulcro-4-id}?t=
:yt-fulcro-5t: https://youtu.be/{yt-fulcro-5-id}?t=

//''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

== Usage ==

=== Client ===

1/ To start shadow process:

[source, bash]
----
bb client:run
----

2/ Connect to Shadow nREPL (if you use Cursive, you can use attached 'client REPL' run config)

3/ To switch to ClojureScript REPL call:

[source, clojure]
----
(dev)
----

When the steps are completed two URLs should be available:

* http://localhost:9630 - ShadowCLJ page
* http://localhost:8000 - website

//''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

== Docs ==

* Fulcro book v3: https://book.fulcrologic.com/

//''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

== Videos ==

=== link:{yt-fulcro-1}[Fulcro – Part 1: Getting Started] ===

video::{yt-fulcro-1-id}[youtube, start=, end=, width=1280, height=720]

==== Content ====

* initial files
* intro to IntelliJ Idea
* how to use Cursive & use REPL from it

==== Notes ====

Commit: "part-1: Add bare project". It includes:

* bare minimal project, incl.
 ** deps.edn, shadow-cljs.edn, index.html
 ** simple client code (cljs) showing "Hello World"

* amended compare to the video
 ** replaced `def APP` with `defonce APP` (possible bug, {yt-fulcro-1t}4m13s[client in part 1], {yt-fulcro-2t}0m0s[client part 2])
 ** added bb.edn
 ** upgraded to the latest versions
  *** fulcro: 3.5.34
  *** shadow-cljs: 2.20.20
  *** react & react-dom: 17.0.2
  *** clojure 1.11.1, clojurescript 1.11.60
  *** jvm: 11.0.17 (Corretto-11.0.17.8.1)
  *** nvm: v18.13.0
 ** fixed 1.11.1 warnings by using newer `com.taoensso/sente`
 ** added `app.client/refresh` to use it for hot reloads

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

=== link:{yt-fulcro-2}[Fulcro – Part 2: Normalization] ===

video::{yt-fulcro-2-id}[youtube, start=, end=, width=1280, height=720]

==== Content ====

* simple layout to list person, their age and they cars
* more on components (idents, query)
* `merge-component!`
* normalized database

==== Notes ====

* `merge-component!` works by taking an ident from the given data and injecting that into APP
* you can't merge root component with `merge-component!` ({yt-fulcro-2t}16m57s[16:57])
* `merge-component!` support replacing particular top thing by added edge (`:replace`)
* `merge-component!` with `:append` adds an edge to given position

==== Commits ====

* *part-2: Demo normalization on simple layout*
** Simple layout includes showing person details:
*** name
*** age
*** cars
** Comments showing how to merge data to the database

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

=== link:{yt-fulcro-3}[Fulcro – Part 3: Initial State and Mutations] ===

video::KJsFLmkdRig[youtube, start=0, end=, width=1280, height=720]

==== Notes ====

===== Initial state _({yt-fulcro-3t}00m00s[00:00])_ =====

The initial state is provided on initial mount (on `(app/mount)`).
Mount is looking at things that need to be there for the first frame to render reasonably.

It is for purely client site setup like:

* UI routing,
* empty state values.

There are two notations for providing initial state.

Longer version:

[source,clojure]
----
:initial-state (fn [{:keys [id name]}]
                   {:person/id   id
                    :person/name name
                    :person/age  20
                    :person/cars [(comp/get-initial-state Car {:id 40 :model "Leaf"})
                                  (comp/get-initial-state Car {:id 41 :model "Escort"})
                                  (comp/get-initial-state Car {:id 42 :model "Sienna"})]})
----

And shorter:

[source,clojure]
----
:initial-state {:person/id   :param/id
                :person/name :param/name
                :person/age  20
                :person/cars [{:id 40 :model "Leaf"}
                              {:id 41 :model "Escort"}
                              {:id 42 :model "Sienna"}]}
----

The shorter version is shorter and gets more error checking
(if you misspell keyword it will point it out).

[CAUTION]
====
The type of data used in examples usually reside on the backend.
In the initial state we provide only purely clients data.
====

===== Mutations _({yt-fulcro-3t}11m18s[11:18])_ =====

* mutation looks like a function, but it returns only data
* `defmutation` in addition, registers mutation name to access later the effects (`action`, `remote`, etc)
* `comp/transact!` is used to apply mutation
* mutation can be visible or not visible at the code level where it is used
* to use it when it is not visible, quote it (optionally unquote params), although IDE will still highlight it
* lots of people hold mutations in separate file from the UI (separation between implementation & the view)

==== Commits ====

* *part-3: Add initial state*
** adds initial state for the app, so when reloaded is not empty

* *part-3: Demo mutations with 'make older' btn*
** adds one button 'make older' that applies mutation to the current user

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

=== link:{yt-fulcro-4}[Fulcro – Part 4 : Components, DOM, and React] ===

video::{yt-fulcro-4-id}[youtube, start=0, end=, width=1280, height=720]

==== Notes ====

===== Styling _({yt-fulcro-4t}00m00s[0:00])_ =====

* to apply styles you can use either:
** short version: `(div :.ui.form ...)`
** long version: `(div {:className "ui form"} ...)`
* `div` is at the same time both function and macro.
Depends on situation fulcro decides to use one or another.
* because macros are evaluated in compile time, and
because of it, fulcro is able to get you exact same
code that JSX would generate for you
* for best performence it is worth to drop the options mape, even if empty, eg. `(div {} ...)` instead of `(div ...)`

===== React lifecycle methods _({yt-fulcro-4t}06:41[06:41])_ =====

* component's map is open, extensible map
* both `:query` and `:initial-state` can be lambdas
* in case of dynamic query support, the `:query` has to be lambda (when data requested at runtime might be different than these setup statically)
* to request component options call `(comp/component-options)`
* react lifecycle methods are a little special in a way that they have a meaning to react, but `defsc` doesn't do anything to it
* `:shouldComponentUpdate` - whether should the component reload or not
* `:componentDidMount`
* `:initLocalState` - this one is a constructor placeholder for react instance.
Whatever is added here, goes to React local state. Local state can be accessed via comp/get-state
it is useful for performance as it.
* If you need to do anything at the construction time, this is the place.
* Tony uses local state very commonly for callback functions
* documentation of `defsc` tells more about these react methods
* fulcro is really fast in pulling data from internal db so typically overhead is not that big to justify trying to optimize by keeping the state in component local state

===== idents _({yt-fulcro-4t}16m26s[16:26])_ =====

* _"it's not uncommon for ust o have components that don't have server identity but for which we do want an identity in our local app database"_
** component that have ident but don't have server identity
** `PersonList` is such an example
* there are a couple of options to specify ident in the component options map:
** `:ident :person/id`
** `:ident [:PEOPLE :person/id]` - will use `:person/id` for ident but in the db it will use `:PEOPLE` as top name
** `:ident (fn [_ _] [:person/id (:person/id props)])` (equivalent of the first one)
* _"when we get to a singleton component, where there's only going to one representation in the database, the id part of the ident is constant, and so we don't want it computed at all"_
** in such scenario we could use `:ident (fn [_ _] [:component/id ::person-list])`

===== use react component _({yt-fulcro-4t}23m38s[23:38])_ =====

* shadow-cljs doesn't need to be restarted to see added libraries (with `npm install`)
* shadow-cljs provides a way to import JS
+
|===
|JavaScript | ClojureScript
| ES5 `const NumberFormat = require('react-number-format');`|`["react-number-format" :as NumberFormat]`
| ES6 `import NumberFormat from 'react-number-format';`|`["react-number-format" :as NumberFormat]`
| ES6 `import { NumericFormat } from 'react-number-format';`|`["react-number-format" :refer (NumericFormat)]`
|===
+
[INFO]
====
DOM inputs in HTML always take string inputs, and always return string outputs.
This includes time, date. Always strings. Remember!
====

==== Commits ====

* *part-4: Demo styling (use Semantic UI)*

* *part-4: Add sample react lifecycle methods*

* *part-4: Assign singleton ident (e.g. people list)*

* *part-4: use react lib (add numeric field)*

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

=== link:{yt-fulcro-5}[Fulcro – Part 5 : How Rendering Works] ===

video::{yt-fulcro-5-id}[youtube, start=0, end=, width=1280, height=720]

==== Notes ====

===== Optimisations _({yt-fulcro-5t}00m00s[0:00])_ =====

* fulcro laverages all react provides
* there is overhead with running the query
* stages
** 1. query
** 2. output of factories (VDOM)
** 3. react DOM diff
* fulcro optimizes:
** 1. query - reduce number of queries
** 2. output of factories (VDOM) - reduce the number that need to run period
** 3. react DOM diff (stable keys for react)
* setting `:shouldComponentUpdate` to true brings default react behaviour
`:shouldComponentUpdate (fn [this props state] true)`
* by default react computes all VDOM components and at the later stage decides via diffing what actually should go to the DOM

===== REPL fulcro components =====

* the optimisation are based on info like:
** what the component needs (`:query`)
** where in the database its data can be found (`:ident`)

* when the component like `Person` mounts, it can be indexed (7:20)
* to look at these indexes:
+
[source,clojure]
----
;; show all classes that query a prop :person/age
(comp/prop->classes APP :person/age) ; => #{:app.client/Person}

;; get class for given class key
(comp/registry-key->class :app.client/Person) ; => app.client/Person

;; show all components rendering Person
(comp/class->all APP Person) ; => #{#object[Component [object Object]] #object[Component [object Object]]}
(comp/class->all APP (comp/registry-key->class :app.client/Person)) ;; same as above

;; having component we can check its ident
(comp/get-ident component) ; => [:person/id 1]

;; get denormalized data having component's id
(let [state (app/current-state APP)
      component-query (comp/get-query Person)
      component-ident [:person/id 1]
      starting-entity (get-in state component-ident)]
   (fdn/db->tree component-query starting-entity state))
; => #:person{:id 1,
;             :name "Bob",
;             :age 20,
;             :cars [#:car{:id 40, :model "Leaf"} #:car{:id 41, :model "Escort"} #:car{:id 42, :model "Sienna"}]}
----
+
* `prop->classes` index trackes components by keyword not by class, because classes can change on hot code reload
* _"if I know `:person/age` changed, I can derive an upper bound for the things that need to be refreshed I need refresh all of the things that have class `Person` in this particular namespace."_
* and with `class->all` it is passible to find all the instances (components)
* with `fdn/db->tree` we can get denormalized data

* the ident based optimisation gets two states, the one before and the one after, and compares for every component whether the data it needs has changed or not

===== ident-optimized-render pros/cons =====

* ident-optimised-render relays on its dependants, but it doesn't check its internal data.
** in the example of ;counting people over 30' Tony shows that if we compute some data within a component based on data from components inside
*** the ident-optimised-render will not detect the change and will not re-render the `PersonList`
*** ident-optimised-render will re-render only the `Person` components that changed, it will not re-render `PersonList`
* so the easy choice is to use keyframe-render (actually in the latest version of the Fulcro this one is the default one)

* the other choice is to provide in a mutation a hint what should be refreshed via `:refresh` (commit `part-5: ident-optimized-render with :refresh`)

==== Commits ====

* *part-5: Log on rendering (but works incorrectly)*

* *part-5: Demo of funs to discover components)*

* *part-5: Demo ident-optimized-render pros/cons*

* *part-5: ident-optimized-render with :refresh*

//''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

== Writing this doc ==

I've been processing the all AsciiDoc files with command:
[source, bash]
----
asciidoctor **/*.adoc; fswatch -o **/*.adoc | xargs -n1 -I{} asciidoctor **/*.adoc
----

Plus serving the HTML via IntelliJ IDEA's `docs/README.html` > Open In > Browser > Firefox.

The link should be something like: http://localhost:63342/fulcro3-yt-tutorial/docs/README.html?&_ij_reload=RELOAD_ON_SAVE
